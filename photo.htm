<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Camera MKV Recorder</title>
<style>
  video { width: 100%; max-width: 600px; border: 1px solid #ccc; }
  select, button { margin: 5px 0; padding: 10px; width: 100%; max-width: 600px; }
</style>
</head>
<body>

<h2>Camera MKV Recorder</h2>

<select id="cameraSelect"></select>
<video id="video" autoplay playsinline></video>
<button id="startStop">Start Recording</button>
<button id="capturePhoto">Capture Photo</button>
<a id="downloadLink" style="display:none">Download MKV</a>
<canvas id="canvas" style="display:none"></canvas>

<script>
const video = document.getElementById('video');
const cameraSelect = document.getElementById('cameraSelect');
const startStopBtn = document.getElementById('startStop');
const capturePhotoBtn = document.getElementById('capturePhoto');
const downloadLink = document.getElementById('downloadLink');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let currentStream = null;
let mediaRecorder = null;
let recordedBlobs = [];
let recording = false;

// Liste des caméras disponibles
async function enumerateCameras() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const videoDevices = devices.filter(d => d.kind === 'videoinput');
  cameraSelect.innerHTML = '';
  videoDevices.forEach((device, i) => {
    const option = document.createElement('option');
    option.value = device.deviceId;
    option.text = device.label || `Camera ${i + 1}`;
    cameraSelect.appendChild(option);
  });
}

// Démarrer le flux caméra
async function startCamera(deviceId) {
  if (currentStream) {
    currentStream.getTracks().forEach(track => track.stop());
  }
  currentStream = await navigator.mediaDevices.getUserMedia({
    video: { deviceId: deviceId ? { exact: deviceId } : undefined },
    audio: true
  });
  video.srcObject = currentStream;

  // Si on est en train d'enregistrer, relancer MediaRecorder
  if (recording) {
    startRecording();
  }
}

// Démarrer / relancer l'enregistrement
function startRecording() {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
  }

  recordedBlobs = recordedBlobs || [];
  let options = { mimeType: 'video/x-matroska;codecs=avc1' }; // MKV H264
  try {
    mediaRecorder = new MediaRecorder(currentStream, options);
  } catch (e) {
    alert('MediaRecorder not supported: ' + e);
    return;
  }

  mediaRecorder.ondataavailable = event => {
    if (event.data && event.data.size > 0) {
      recordedBlobs.push(event.data);
    }
  };

  mediaRecorder.start(1000); // envoie les blobs toutes les secondes
}

// Bouton Start / Stop
startStopBtn.addEventListener('click', () => {
  if (!recording) {
    recording = true;
    startRecording();
    startStopBtn.textContent = 'Stop Recording';
  } else {
    recording = false;
    mediaRecorder.stop();
    startStopBtn.textContent = 'Start Recording';
    const superBlob = new Blob(recordedBlobs, { type: 'video/x-matroska' });
    downloadLink.href = URL.createObjectURL(superBlob);
    downloadLink.download = 'recording.mkv';
    downloadLink.style.display = 'block';
    downloadLink.textContent = 'Download MKV';
  }
});

// Changement de caméra
cameraSelect.addEventListener('change', () => {
  startCamera(cameraSelect.value);
});

// Capture photo
capturePhotoBtn.addEventListener('click', () => {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  const photoBlob = canvas.toBlob(blob => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'photo.jpg';
    a.click();
  }, 'image/jpeg', 0.95);
});

// Initialisation
enumerateCameras().then(() => startCamera());
</script>

</body>
</html>
